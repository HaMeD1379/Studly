//This test class was generated by chatGPT
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { formatISOToYYYYMMDD } from '~/utilities/time';
import { loader } from './loader';

const {
  mockFetchTodaysSessionSummary,
  mockGetProfile,
  mockFetchAllUserBadges,
} = vi.hoisted(() => ({
  mockFetchAllUserBadges: vi.fn(),
  mockFetchTodaysSessionSummary: vi.fn(),
  mockGetProfile: vi.fn(),
}));

vi.mock('~/api', () => ({
  fetchTodaysSessionSummary: mockFetchTodaysSessionSummary,
  getProfile: mockGetProfile,
}));

vi.mock('~/api/badges', () => ({
  fetchAllUserBadges: mockFetchAllUserBadges,
}));

vi.mock('~/store', () => ({
  userInfo: {
    getState: () => ({ userId: 'user-123' }),
  },
}));

describe('Home loader()', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns correctly combined data when all API calls succeed', async () => {
    mockFetchTodaysSessionSummary.mockResolvedValue({
      data: { totalMinutesStudied: 90 },
      error: false,
    });

    mockGetProfile.mockResolvedValue({
      data: { data: { bio: 'Keep learning!', full_name: 'Alice' } },
      error: false,
    });

    mockFetchAllUserBadges.mockResolvedValue({
      data: {
        badges: [
          {
            badge: { description: 'Study 1 hour', name: 'Quick Learner' },
            progress: 60,
          },
          {
            badge: { description: 'Study 10 hours', name: 'Dedicated' },
            earnedAt: '2025-01-01T00:00:00Z',
          },
        ],
      },
      error: false,
    });

    const result = await loader();

    expect(result.error).toBe(false);
    expect(result.data.todaySession).toEqual({ totalMinutesStudied: 90 });
    expect(result.data.userProfileInfo).toEqual({
      data: { bio: 'Keep learning!', full_name: 'Alice' },
    });

    expect(result.data.allBadges).toHaveLength(2);
    expect(result.data.inProgressBadges).toEqual([
      { description: 'Study 1 hour', name: 'Quick Learner', progress: 60 },
    ]);
    expect(result.data.unlockedBadges).toEqual([
      {
        description: 'Study 10 hours',
        earnedAt: formatISOToYYYYMMDD('2025-01-01T00:00:00Z'),
        name: 'Dedicated',
      },
    ]);
  });

  it('handles badges with no progress or earnedAt gracefully', async () => {
    mockFetchTodaysSessionSummary.mockResolvedValue({ data: {}, error: false });
    mockGetProfile.mockResolvedValue({ data: {}, error: false });
    mockFetchAllUserBadges.mockResolvedValue({
      data: {
        badges: [
          { badge: { description: 'No data', name: 'EmptyBadge' } },
          {
            badge: { description: 'In progress', name: 'Halfway' },
            progress: 50,
          },
        ],
      },
      error: false,
    });

    const result = await loader();

    expect(result.data.allBadges).toHaveLength(2);
    expect(result.data.inProgressBadges).toHaveLength(1);
    expect(result.data.unlockedBadges).toEqual([]);
  });

  it('sets error to true when todaySession or profile has errors', async () => {
    mockFetchTodaysSessionSummary.mockResolvedValue({
      data: {},
      error: true,
    });
    mockGetProfile.mockResolvedValue({
      data: {},
      error: false,
    });
    mockFetchAllUserBadges.mockResolvedValue({
      data: { badges: [] },
      error: false,
    });

    const result = await loader();
    expect(result.error).toBe(true);
  });

  it('returns empty arrays if badge response is missing data', async () => {
    mockFetchTodaysSessionSummary.mockResolvedValue({ data: {}, error: false });
    mockGetProfile.mockResolvedValue({ data: {}, error: false });
    mockFetchAllUserBadges.mockResolvedValue({ data: null, error: true });

    const result = await loader();
    expect(result.data.allBadges).toEqual([]);
    expect(result.data.unlockedBadges).toEqual([]);
    expect(result.data.inProgressBadges).toEqual([]);
  });
});
